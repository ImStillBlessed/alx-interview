#!/usr/bin/python3
"""
A simple log parsing script.

This script reads log entries from standard input,
extracts HTTP status codes and file sizes,
and prints statistics about these values.
The script handles keyboard interruptions gracefully,
printing the collected statistics before exiting.

Expected log format:
<ip> - [<date> <time>] "GET /projects/260 HTTP/1.1" <status_code> <file_size>

Example log entry:
127.0.0.1 - [2023-05-20 13:55:36] "GET /projects/260 HTTP/1.1" 200 512

Usage:
    cat access.log | ./log_parser.py
"""

import sys
import signal
import re

# Initialize total file size counter
total_file_size = 0

# Initialize status code counters
status_code_count = {
    200: 0,
    301: 0,
    400: 0,
    401: 0,
    403: 0,
    404: 0,
    405: 0,
    500: 0
}

# Initialize line counter
line_counter = 0

# Regular expression pattern to match log lines
log_pattern = re.compile(
    r'^\S+ - \[\S+ \S+\] "GET /projects/260 HTTP/1.1" (\d{3}) (\d+)$'
)


def print_stats():
    """
    Prints the accumulated statistics of file sizes and status codes.

    This function prints the total file size and the
    count of each HTTP status code
    that has been encountered more than zero times.
    """
    print(f"File size: {total_file_size}")
    for code in sorted(status_code_count.keys()):
        if status_code_count[code] > 0:
            print(f"{code}: {status_code_count[code]}")


def signal_handler(sig, frame):
    """
    Handles keyboard interruption signals.

    This function catches SIGINT (typically generated by pressing Ctrl+C) and
    prints the statistics collected so far before exiting the program.

    Args:
        sig (int): The signal number.
        frame (frame object): The current stack frame.
    """
    print_stats()
    sys.exit(0)


# Register the signal handler for SIGINT
signal.signal(signal.SIGINT, signal_handler)

try:
    while True:
        line = sys.stdin.readline()
        if not line:
            break  # Exit loop if no more input
        match = log_pattern.match(line)
        if not match:
            continue
        try:
            # Extract status code and file size from the matched groups
            status_code = int(match.group(1))
            file_size = int(match.group(2))

            # Update total file size
            total_file_size += file_size

            # Update status code count
            if status_code in status_code_count:
                status_code_count[status_code] += 1

            # Increment line counter
            line_counter += 1

            # Print statistics every 10 lines
            if line_counter % 10 == 0:
                print_stats()

        except (ValueError, IndexError):
            # Continue to the next line in case of a parsing error
            continue

    # Print final statistics after the loop ends
    print_stats()

except KeyboardInterrupt:
    # Print statistics and exit on keyboard interruption
    print_stats()
    sys.exit(0)
